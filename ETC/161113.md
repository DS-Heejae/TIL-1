# 객체지향 개발 5 원칙 

객체지향 아래에서의 클래스의 설계와 구현에 있어서 지키면 좋은 5가지의 원칙이 있다. 개인적으로 이러한 규칙들은 강제되어 개발자들의 협업에서 적용 되어야 한다고 생각 된다. 

복잡한 인터페이스와 구현이 얽히고 거기에 View의 업데이트와 콜백들이 존재 하여 라인수가 극도로 많아지는 환경에서 중요한 객체지향 개발에서 지켜야 할 5개의 원칙을 정리 해 보았다. 

## 1. SRP (단일 책임의 원칙 / Single Responsibility Principle)

- 모든 클래스는 **단 하나의 책임**을 가져야 한다. 클래스는 수정할 이유가 오직 하나 이어야만 한다.
- 클래스는 자신의 클래스의 책임을 의미 하는 **이름**이 나타내는 기능만을 수행 할 수 있어야 한다. 올바른 클래스의 이름은 해당 클래스의 책임을 명확하게 할 수 있는 가장 좋은 방법 이 될 수 있다.  
- 예를 들어 `계산기`를 구현한 클래스에서는 `계산`의 기능을 수행하는 메소드만 존재 해야 한다. 여기에 다른 작업들 예를 들어 `View`의 업데이트같은 다른 기능을 갖는 코드(다른 요구사항에 대한 책임이 구현된)를 추가 하게 되면 SRP를 위반하게 되는 것 이다. 
- 책임을 적절히 분배함으로써 코드의 가독성이 향상 되고 유지 보수가 용이해지는 이점이 생긴다. 또한 다른 객체지향 원칙들 중 OCP원리 뿐 아니라 다른 원리를 적용시킬 수 있는 기초가 된다. 
- 실무에서는 다양한 업무와 요구사항이 빈번하게 적용, 변경 되기 때문에 경험이 많지 않다면 SRP를 어기기 쉽다. 특히 일정에 쫓기며 작업하게 잘 알수 있을 것 이다.  

## 2. OCP (개방 폐쇄의 원칙 / Open Close Principle)

- 모든 소프트웨어 구성 요소는 확장 요소에 대해서는 개방 되어 있지만, 수정에 대해서는 폐쇄되어있다는 원칙 이다. 
- 예를 들어 어떤 부모 클래스에서 메소드를 만든 뒤 이 클래스를 상속한 자식 클래스에서는 부모에서 구현한 메소드 들을 재정의 하여 사용 할 수 있지만(기능의 확장) 부모 클래스의 메소드를 수정 할 수 없다. 
- 구현된 클래스의 변경에 대한 비용을 최대한 줄이고(사실상 없는게 좋다), 확장을 위한 비용을 최대화 시킨다. 이는 요구사항의 추가나 변경이 발생 하더라도 기존 구성 요소의 수정은 억제 하며, 기존 구성 요소를 확장하여 **재사용**하게 할 수 있어야 한다는 것 이다. 
- 확장 될 것과 그렇지 않은 것을 명확하게 구분 하고 다른 모듈이 만날때를 대비한 인터페이스를 정의 한다. (정의될 인터페이스는 앞으로도 변경되지 않는 것이 좋다. 그렇기 때문에 설계 시점에서 적절한 수준의 예측 능력이 필 수라 할 수 있다.) 
- 구현에 의존하기보다는 정의된 인터페이스에 의존하도록 코드를 작성 한다. 
- 인터페이스의 설계에 있어 적절한 추상화 레벨을 선택 해야 한다. 

## 3. LSP (리스코브 치환의 원칙 / The Liskov Substitution Principle)

- 자식 클래스는 그 부모 클래스를 교체 할 수 있다는 원칙. 
- 부모 클래스에 자식 클래스를 대체 해도 잘 동작 해야 한다. (상속의 원칙인 is A 관계를 잘 생각해 보자)
- 예로 `A`클래스를 상속한 `B`클래스의 인스턴스를 생성 했을때 `A`클래스의 기능은 온전히 잘 실행 되어야 한다. 
- Java에서의 `Collection`을 구현한 클래스들과 `Collection`의 관계를 토대로 LSP를 정의할 수 있다. (`Collection`이라는 부모 클래스-인터페이스 에서 구현된 메소드는 이를 상속한 다른 객체(`HashMap`이나 `ArrayList`등 자바의 컬렉션들)을 통해서 인스턴스를 생성(`new`)하여 사용 해도 `Collection`에서 정의한 기능들을 온전히 제공 한다.)

## 4. ISP (인터페이스 분리의 원칙 / Interface Segregation Principle )

- 클라이언트에서 당장 사용하지 않는 메소드는 구현하지 않는다. 그래서 인터페이스는 잘게 나누어 구현 한다. 
- 예를 들어 `계산기`라는 클래스에서는 우선 `더하기`, `빼기` 기능을 구현한다. 하지만 당장 필요하지 않은 공학용계산기 등의 기능은 구현할 필요가 없으므로 메소드를 만들지 않는다. 필요하게 된 다면 이를 상속 하여 새로운 기능을 구현 하면 된다.  
- 두 개 이상의 인터페이스가 공유되는 부분의 재 사용을 극대화 하고, 서로 다른 성격의 인터페이스를 명백히 분리 한다. 

## 5. DIP (의존성 역전의 원칙 / Dependency Inversion Principle)

- 부모 클래스는 자식 클래스에 의존 하면 안 된다. 
- 객체지향에서 클래스의 설계에 있어 당연한 것 이다. 몰론 복잡한 구현에서 급한 필요에 의해 자식 클래스에서 부모의 인스턴스를 갖을 수도 있지만 이는 추상을 통해서 메시지를 주고 받음으로 처리 하는게 좋다.  

