# Graph 그래프 

정점(Node, Vertex)과 정점들 간의 관계를 나타내는 간선(Edge)로 이루어진 자료 구조. 보통 그래프는 `G=(V,E)`로 표현 한다. 

![graph1](https://github.com/ksu3101/TIL/blob/master/DS/image/g1.png)

이 예제 그래프의 이미지의 경우는 **방향이 존재 하는 그래프**`Directed Graph` 로서 `A -> C`와 같이 간선에 방향이 존재 한다. 하지만 그 역 경로인 `C -> A`로는 갈 수가 없다.  

그와 다르게 방향이 없는 그래프는 화살표가 아닌 각 정점을 잇는 간선만 존재 하며 **양방향 그래프**`Bidirection Graph`라고도 한다. 

## 그래프에서 사용 되는 용어 

1. **경로, Path**  
 
 정점에서 다른 정점으로 가는 경로를 말한다.위 그림에서 `정점 A`에서 `정점 B`로 가는 경로는 다음과 같다.  
   
 - A -> C -> D -> E -> B
 - A -> B
 - A -> C -> B
 - A -> C -> E -> B

 경로에서 같은 정점을 두 번 이상 방문하지 않는 경로를 **단순 경로**`Simple path` 라고 한다. 일반적으로 사용 하는 경로는 이러한 단순 경로를 말 한다.

 또한 두 정점 사이에 간선이 여러개 일 수도 있다. 이럴때 두 간선은 서로 다른 간선 이다. 

2. **사이클, Cycle**
 
 정점 에서 동일한 정점으로 다시 돌아오는 경로를 뜻 한다. 위 그림에서 `정점 A`의 사이클은 다음과 같다.  
 단순 경로와 마찬가지로 같은 정점을 두 번 이상 방문 하지 않는 사이클을 **단순 사이클**`Simple cycle`이라고 한다. 

 - A -> C -> B -> A
 - A -> C -> E -> B -> A
 - A -> C -> D -> E -> B -> A

3. **루프, Loop** 

 간선의 양 끝점이 같은 경우가 있다. 예를 들면 위 그림에서 `A -> A`인 경우 이다. 


4. **가중치, Weight** 

 간선에 가중치라는 값이 존재 할 수 있다. 보통 이 값은 `A`정점에서 `B`정점으로 이동 하는 거리, 이동하는데 필요한 시간, 비용등을 의미 한다. 보통 가중치가 존재 하지 않는 경우에는 `1`이라고 생각 하면 된다. 

 그래프 에서의 표현은 아래 예제 이미지와 같다. 

![graph2](https://github.com/ksu3101/TIL/blob/master/DS/image/g2.png)

5. **차수, Degree**

 정점과 연결된 모든 간선의 갯수를 말한다. 위 예제 그래프 이미지의 예를 들면 다음과 같다. 

 - `A` 정점의 차수 : 2
 - `C` 정점의 차수 : 4
 - `E` 정점의 차수 : 3 

## 그래프의 표현 

1. 기본 표현 

 ![graph3](https://github.com/ksu3101/TIL/blob/master/DS/image/g3.png)

 위 그래프 예제 에서는 정점이 6개, 간선이 8개 존재 한다. 간선에 방향이 없으므로 방향이 없는 그래프 이다. 

 - 정점 : `{1, 2, 3, 4, 5, 6}`
 - 간선 : `{(1, 2), (1, 5), (2, 5), (2, 3), (3, 4), (2, 4), (4, 5), (4, 6)}`

 가중치의 표현은 아래 그래프의 데이터 표현 내용에서 다룬다.  

2. 인접 행렬 (Adjacency matrix)

 정점의 갯수가 `n`일 경우 `n * n` 크기의 2차원 배열을 사용 한다. 위 그래프 예제를 2차원 배열로 표현하면 다음과 같다.  

 *|1|2|3|4|5|6
 -----|-|-|-|-|-|-|
 **1**|0|1|0|0|1|0
 **2**|1|0|1|1|1|0
 **3**|0|1|0|1|0|0
 **4**|0|1|1|0|1|1
 **5**|1|1|0|1|0|0
 **6**|0|0|0|1|0|0

 만약 가중치의 값을 설정 하고 싶다면 해당 하는 배열의 `A[i][j] = weight` 형태로 간선이 있을때 그 가중치를 해당 배열 인덱스에 설정 한다. 
 위 그래프 예제를 이용하여 2차원 배열로 표현하면 다음과 같다.   

  *|1|2|3|4|5|6
 -----|-|-|-|-|-|-|
 **1**|0|2|0|0|7|0
 **2**|2|0|2|3|1|0
 **3**|0|2|0|1|0|0
 **4**|0|3|1|0|7|7
 **5**|7|1|0|7|0|0
 **6**|0|0|0|7|0|0 

 초기 데이터를 입력받아 세팅하는 부분을 구현하면 다음과 같다. 

 ```java
public class GraphMain {
  public static void main(String[] args) {
    Scanner s = new Scanner(System.in);
    
    int n = s.nextInt();  // 정점의 갯수    
    int e = s.nextInt();  // 간선의 갯수
    
    int[][] array = new int[n][n];
    for(int i=0; i<e; i++) {
      int u = s.nextInt();    // 간선의 정점1
      int v = s.nextInt();    // 간선의 정점2
      int w = s.nextInt();    // 간선의 가중치 값
      
      array[u][v] = array[v][u] = w; 
    }
    printArray(array);
  }
  
  private static void printArray(int[][] a) {
    for(int i=0; i<a.length; i++) {
      for(int j=0; j<a[i].length; j++) {
        System.out.print(a[i][j]);
        if(j < a[i].length - 1) {
          System.out.print(", ");
        }
      }
      System.out.println("");
    }
  }
}
 ```

 ```
 6 8
0 1 2
0 4 7
1 2 2
1 3 3
1 4 1
4 3 7
3 2 1
3 5 7
 ```
 위와 같은 값을 실제로 입력 한 뒤 `printArray()`메소드를 호출 하여 2차원 배열의 값을 확인 하면 아래와 같다. 

 ```
0, 2, 0, 0, 7, 0
2, 0, 2, 3, 1, 0 
0, 2, 0, 1, 0, 0 
0, 3, 1, 0, 7, 7 
7, 1, 0, 7, 0, 0 
0, 0, 0, 7, 0, 0 
 ```


3. 인접 리스트 (Adjacency list)


## 그래프의 탐색 


## 그래프 관련 알고리즘 
