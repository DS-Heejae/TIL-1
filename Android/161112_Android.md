# RxJava (Reactive Extensions Java) / 작성 중    

## 1. RxJava (RxAndroid)

안드로이드 개발을 하다보면 생각보다 비동기 작업을 하는 경우가 매우 많다. 네트워크 콜이나 파일 I/O등 메인 스레드에서 할 수 없는 작업들이 많기 때문이다. 이런 비동기 작업의 구현은 어렵지 않을지 몰라도 그 이후가 문제가 될 수 있다. 

특히 비동기작업 후 뷰의 업데이트를 위한 메인스레드로의 콜백의 정의와 구현이 많아지면 많아질 수록 내부 소스는 복잡해 진다. 사실상 비슷한 패턴인 `비동기 작업 -> 작업 후 -> 상황(에러, 정상적인 케이스, 그 외 작업의 진행)에 따른 뷰의 업데이트`라는 동일한 패턴은 비슷하지만 내부의 비즈니스로직 등만이 다른 경우가 태반이다. 이러한 반복적인 개발은 단순하게 하고 싶은 욕심이 있었었다. 

[RxJava의 위키 페이지 내용](https://github.com/ReactiveX/RxJava/wiki) 에서 일부 정보를 정리해 보았다.

## 2. [Observable](https://github.com/ReactiveX/RxJava/wiki/Observable)  

RxJava에서 *Observer* 와 *subscribes* 등 인터페이스들의 구현될 클래스는 *Observable* 이다. 이는 Observer 디자인 패턴과 Iteration 디자인 패턴을 결합 한 형태에 `생산자 - 소비자` 형태의 패턴을 갖는다.   

## 2. [Async Operators](https://github.com/ReactiveX/RxJava/wiki/Async-Operators) 

아래의 operation들은 `rxjava-async` 모듈의 일부 이다. 

- `start( )` — Observable 을 생성하고 구현한 메소드에서 반환한 결과를 내보낸다.
- `toAsync( ) or asyncAction( ) or asyncFunc( )` — convert a function or Action into an Observable that executes the function and emits its return value
- `startFuture( )` — convert a function that returns Future into an Observable that emits that Future's return value
- `deferFuture( )` — convert a Future that returns an Observable into an Observable, but do not attempt to get the Observable that the Future returns until a Subscriber subscribes
- `forEachFuture( )` — pass Subscriber methods to an Observable but also have it behave like a Future that blocks until it completes
- `fromAction( )` — convert an Action into an Observable that invokes the action and emits its result when a Subscriber subscribes
- `fromCallable( )` — convert a Callable into an Observable that invokes the callable and emits its result or exception when a Subscriber subscribes
- `fromRunnable( )` — convert a Runnable into an Observable that invokes the runable and emits its result when a Subscriber subscribes
- `runAsync( )` — returns a StoppableObservable that emits multiple actions as generated by a specified Action on a Scheduler

## 3. [Blocking Observable Operators](https://github.com/ReactiveX/RxJava/wiki/Blocking-Observable-Operators) 

This section explains the `BlockingObservable` subclass. A Blocking Observable extends the ordinary Observable class by providing a set of operators on the items emitted by the Observable that block.

To transform an `Observable` into a `BlockingObservable`, use the `Observable.toBlocking( )` method or the `BlockingObservable.from( )` method.

- `forEach( )` — invoke a function on each item emitted by the Observable; block until the Observable completes
- `first( )` — block until the Observable emits an item, then return the first item emitted by the Observable
- `firstOrDefault( )` — block until the Observable emits an item or completes, then return the first item emitted by the Observable or a default item if the Observable did not emit an item
- `last( )` — block until the Observable completes, then return the last item emitted by the Observable
- `lastOrDefault( )` — block until the Observable completes, then return the last item emitted by the Observable or a default item if there is no last item
- `mostRecent( )` — returns an iterable that always returns the item most recently emitted by the Observable
- `next( )` — returns an iterable that blocks until the Observable emits another item, then returns that item
- `latest( )` — returns an iterable that blocks until or unless the Observable emits an item that has not been returned by the iterable, then returns that item
- `single( )` — if the Observable completes after emitting a single item, return that item, otherwise throw an exception
- `singleOrDefault( )` — if the Observable completes after emitting a single item, return that item, otherwise return a default item
- `toFuture( )` — convert the Observable into a Future
- `toIterable( )` — convert the sequence emitted by the Observable into an Iterable
- `getIterator( )` — convert the sequence emitted by the Observable into an Iterator

## 4. [Combining Operators](https://github.com/ReactiveX/RxJava/wiki/Combining-Observables) 

This section explains operators you can use to combine multiple Observables.

- `startWith( )` — emit a specified sequence of items before beginning to emit the items from the Observable
- `merge( )` — combine multiple Observables into one
- `mergeDelayError( )` — combine multiple Observables into one, allowing error-free Observables to continue before propagating errors
- `zip( )` — combine sets of items emitted by two or more Observables together via a specified function and emit items based on the results of this function
- `(rxjava-joins) and( ), then( ), and when( )` — combine sets of items emitted by two or more Observables by means of Pattern and Plan intermediaries
- `combineLatest( )` — when an item is emitted by either of two Observables, combine the latest item emitted by each Observable via a specified function and emit items based on the results of this function
- `join( ) and groupJoin( )` — combine the items emitted by two Observables whenever one item from one Observable falls within a window of duration specified by an item emitted by the other Observable
- `switchOnNext( )` — convert an Observable that emits Observables into a single Observable that emits the items emitted by the most-recently emitted of those Observables

## 5. [Conditional and Boolean Operatiors](https://github.com/ReactiveX/RxJava/wiki/Conditional-and-Boolean-Operators)

This section explains operators with which you conditionally emit or transform Observables, or can do boolean evaluations of them:

### 5.1 Conditional Operators

- `amb( )` — given two or more source Observables, emits all of the items from the first of these Observables to emit an item
- `defaultIfEmpty( )` — emit items from the source Observable, or emit a default item if the source Observable completes after emitting no items
- `(rxjava-computation-expressions) doWhile( )` — emit the source Observable's sequence, and then repeat the sequence as long as a condition remains true
- `(rxjava-computation-expressions) ifThen( )` — only emit the source Observable's sequence if a condition is true, otherwise emit an empty or default sequence
- `skipUntil( )` — discard items emitted by a source Observable until a second Observable emits an item, then emit the remainder of the source Observable's items
- `skipWhile( )` — discard items emitted by an Observable until a specified condition is false, then emit the remainder
- `(rxjava-computation-expressions) switchCase( )` — emit the sequence from a particular Observable based on the results of an evaluation
- `takeUntil( )` — emits the items from the source Observable until a second Observable emits an item or issues a notification
- `takeWhile( ) and takeWhileWithIndex( )` — emit items emitted by an Observable as long as a specified condition is true, then skip the remainder
- `(rxjava-computation-expressions) whileDo( )` — if a condition is true, emit the source Observable's sequence and then repeat the sequence as long as the condition remains true

### 5.2 Boolean Operators 

- `all( )` — determine whether all items emitted by an Observable meet some criteria
- `contains( )` — determine whether an Observable emits a particular item or not
- `exists( ) and isEmpty( )` — determine whether an Observable emits any items or not
- `sequenceEqual( )` — test the equality of the sequences emitted by two Observables

## 6. [Connectable Observable Operators](https://github.com/ReactiveX/RxJava/wiki/Connectable-Observable-Operators)

This section explains the ConnectableObservable subclass and its operators:

- `ConnectableObservable.connect( )` — instructs a Connectable Observable to begin emitting items
- `Observable.publish( )` — represents an Observable as a Connectable Observable
- `Observable.replay( )` — ensures that all Subscribers see the same sequence of emitted items, even if - they subscribe after the Observable begins emitting the items
- `ConnectableObservable.refCount( )` — makes a Connectable Observable behave like an ordinary Observable

A Connectable Observable resembles an ordinary Observable, except that it does not begin emitting items when it is subscribed to, but only when its connect() method is called. In this way you can wait for all intended Subscribers to subscribe to the Observable before the Observable begins emitting items.


## 7. [Error Handling Operators](https://github.com/ReactiveX/RxJava/wiki/Error-Handling-Operators)

There are a variety of operators that you can use to react to or recover from `onError` notifications from Observables. For example, you might:

1. swallow the error and switch over to a backup Observable to continue the sequence
2. swallow the error and emit a default item
3. swallow the error and immediately try to restart the failed Observable
4. swallow the error and try to restart the failed Observable after some back-off interval

The following pages explain these operators.

- `onErrorResumeNext( )` — instructs an Observable to emit a sequence of items if it encounters an error
- `onErrorReturn( )` — instructs an Observable to emit a particular item when it encounters an error
- `onExceptionResumeNext( )` — instructs an Observable to continue emitting items after it encounters an exception (but not another variety of throwable)
- `retry( )` — if a source Observable emits an error, resubscribe to it in the hopes that it will complete without error
- `retryWhen( )` — if a source Observable emits an error, pass that error to another Observable to determine whether to resubscribe to the source

### [RxJava-specific Exceptions](https://github.com/ReactiveX/RxJava/wiki/Error-Handling) 

- `CompositeException`

 This indicates that more than one exception occurred. You can use the exception’s getExceptions() method to retrieve the individual exceptions that make up the composite.

- `MissingBackpressureException`

 This indicates that a Subscriber or operator attempted to apply reactive pull backpressure to an Observable that does not implement it. See Backpressure for work-arounds for Observables that do not implement reactive pull backpressure.

- `OnErrorFailedException`

 This indicates that an Observable tried to call its observer’s onError() method, but that method itself threw an exception.

- `OnErrorNotImplementedException`

 This indicates that an Observable tried to call its observer’s onError() method, but that no such method existed. You can eliminate this by either fixing the Observable so that it no longer reaches an error condition, by implementing an onError handler in the observer, or by intercepting the onError notification before it reaches the observer by using one of the operators described elsewhere on this page.

- `OnErrorThrowable`

 Observers pass throwables of this sort into their observers’ onError() handlers. A Throwable of this variety contains more information about the error and about the Observable-specific state of the system at the time of the error than does a standard Throwable.

## 8. [Filtering Observables](https://github.com/ReactiveX/RxJava/wiki/Filtering-Observables)

This page shows operators you can use to filter and select items emitted by Observables.

- `filter( )` — filter items emitted by an Observable
- `takeLast( )` — only emit the last n items emitted by an Observable
- `last( )` — emit only the last item emitted by an Observable
- `lastOrDefault( )` — emit only the last item emitted by an Observable, or a default value if the source Observable is empty
- `takeLastBuffer( )` — emit the last n items emitted by an Observable, as a single list item
- `skip( )` — ignore the first n items emitted by an Observable
- `skipLast( )` — ignore the last n items emitted by an Observable
- `take( )` — emit only the first n items emitted by an Observable
- `first( ) and takeFirst( )` — emit only the first item emitted by an Observable, or the first item that meets some condition
- `firstOrDefault( )` — emit only the first item emitted by an Observable, or the first item that meets some condition, or a default value if the source Observable is empty
- `elementAt( )` — emit item n emitted by the source Observable
- `elementAtOrDefault( )` — emit item n emitted by the source Observable, or a default item if the source Observable emits fewer than n items
- `sample( ) or throttleLast( )` — emit the most recent items emitted by an Observable within periodic time intervals
- `throttleFirst( )` — emit the first items emitted by an Observable within periodic time intervals
- `throttleWithTimeout( ) or debounce( )` — only emit an item from the source Observable after a particular timespan has passed without the Observable emitting any other items
- `timeout( )` — emit items from a source Observable, but issue an exception if no item is emitted in a specified timespan
- `distinct( )` — suppress duplicate items emitted by the source Observable
- `distinctUntilChanged( )` — suppress duplicate consecutive items emitted by the source Observable
- `ofType( )` — emit only those items from the source Observable that are of a particular class
- `ignoreElements( )` — discard the items emitted by the source Observable and only pass through the error or completed notification

## 9. [Mathematical and Aggregrate Operators](https://github.com/ReactiveX/RxJava/wiki/Mathematical-and-Aggregate-Operators)

This page shows operators that perform mathematical or other operations over an entire sequence of items emitted by an Observable. Because these operations must wait for the source Observable to complete emitting items before they can construct their own emissions (and must usually buffer these items), these operators are dangerous to use on Observables that may have very long or infinite sequences.

### 9. 1 Operators in the rxjava-math module

- `averageInteger( )` — calculates the average of Integers emitted by an Observable and emits this average
- `averageLong( )` — calculates the average of Longs emitted by an Observable and emits this average
- `averageFloat( )` — calculates the average of Floats emitted by an Observable and emits this average
- `averageDouble( )` — calculates the average of Doubles emitted by an Observable and emits this average
- `max( )` — emits the maximum value emitted by a source Observable
- `maxBy( )` — emits the item emitted by the source Observable that has the maximum key value
- `min( )` — emits the minimum value emitted by a source Observable
- `minBy( )` — emits the item emitted by the source Observable that has the minimum key value
- `sumInteger( )` — adds the Integers emitted by an Observable and emits this sum
- `sumLong( )` — adds the Longs emitted by an Observable and emits this sum
- `sumFloat( )` — adds the Floats emitted by an Observable and emits this sum
- `sumDouble( )` — adds the Doubles emitted by an Observable and emits this sum

### 9. 2 Other Aggregate Operators

- `concat( )` — concatenate two or more Observables sequentially
- `count( ) and countLong( )` — counts the number of items emitted by an Observable and emits this count
- `reduce( )` — apply a function to each emitted item, sequentially, and emit only the final accumulated value
- `collect( )` — collect items emitted by the source Observable into a single mutable data structure and return an Observable that emits this structure
- `toList( )` — collect all items from an Observable and emit them as a single List
- `toSortedList( )` — collect all items from an Observable and emit them as a single, sorted List
- `toMap( )` — convert the sequence of items emitted by an Observable into a map keyed by a specified key function
- `toMultiMap( )` — convert the sequence of items emitted by an Observable into an ArrayList that is also a map keyed by a specified key function

## 10. [Creating Observables](https://github.com/ReactiveX/RxJava/wiki/Creating-Observables)

This page shows methods that create Observables.

- `just( )` — convert an object or several objects into an Observable that emits that object or those objects
- `from( )` — convert an Iterable, a Future, or an Array into an Observable
- `create( )` — advanced use only! create an Observable from scratch by means of a function, consider fromEmitter instead
- `fromEmitter()` — create safe, backpressure-enabled, unsubscription-supporting Observable via a function and push events.
- `defer( )` — do not create the Observable until a Subscriber subscribes; create a fresh Observable on each subscription
- `range( )` — create an Observable that emits a range of sequential integers
- `interval( )` — create an Observable that emits a sequence of integers spaced by a given time interval
- `timer( )` — create an Observable that emits a single item after a given delay
- `empty( )` — create an Observable that emits nothing and then completes
- `error( )` — create an Observable that emits nothing and then signals an error
- `never( )` — create an Observable that emits nothing at all

## 11. [String Observables](https://github.com/ReactiveX/RxJava/wiki/String-Observables)

The `StringObservable` class contains methods that represent operators particular to Observables that deal in string-based sequences and streams. These include:

- `byLine( )` — converts an Observable of Strings into an Observable of Lines by treating the source sequence as a stream and splitting it on line-endings
- `decode( )` — convert a stream of multibyte characters into an Observable that emits byte arrays that respect character boundaries
- `encode( )` — transform an Observable that emits strings into an Observable that emits byte arrays that respect character boundaries of multibyte characters in the original strings
- `from( )` — convert a stream of characters or a Reader into an Observable that emits byte arrays or Strings
- `join( )` — converts an Observable that emits a sequence of strings into an Observable that emits a single string that concatenates them all, separating them by a specified string
- `split( )` — converts an Observable of Strings into an Observable of Strings that treats the source sequence as a stream and splits it on a specified regex boundary
- `stringConcat( )` — converts an Observable that emits a sequence of strings into an Observable that emits a single string that concatenates them all

## 12. [Transforming Observables](https://github.com/ReactiveX/RxJava/wiki/Transforming-Observables)

This page shows operators with which you can transform items that are emitted by an Observable.

- `map( )` — transform the items emitted by an Observable by applying a function to each of them
- `flatMap( ), concatMap( ), and flatMapIterable( )` — transform the items emitted by an Observable into Observables (or Iterables), then flatten this into a single Observable
- `switchMap( )` — transform the items emitted by an Observable into Observables, and mirror those items emitted by the most-recently transformed Observable
- `scan( )` — apply a function to each item emitted by an Observable, sequentially, and emit each successive value
- `groupBy( )` — divide an Observable into a set of Observables that emit groups of items from the original Observable, organized by key
- `buffer( )` — periodically gather items from an Observable into bundles and emit these bundles rather than emitting the items one at a time
- `window( )` — periodically subdivide items from an Observable into Observable windows and emit these windows rather than emitting the items one at a time
- `cast( )` — cast all items from the source Observable into a particular type before reemitting them

## 13. [Observable Utility Operators](https://github.com/ReactiveX/RxJava/wiki/Observable-Utility-Operators)

This page lists various utility operators for working with Observables.

- `materialize( )` — convert an Observable into a list of Notifications
- `dematerialize( )` — convert a materialized Observable back into its non-materialized form
- `timestamp( )` — attach a timestamp to every item emitted by an Observable
- `serialize( )` — force an Observable to make serialized calls and to be well-behaved
- `cache( )` — remember the sequence of items emitted by the Observable and emit the same sequence to future Subscribers
- `observeOn( )` — specify on which Scheduler a Subscriber should observe the Observable
- `subscribeOn( )` — specify which Scheduler an Observable should use when its subscription is invoked
- `doOnEach( )` — register an action to take whenever an Observable emits an item
- `doOnCompleted( )` — register an action to take when an Observable completes successfully
- `doOnError( )` — register an action to take when an Observable completes with an error
- `doOnTerminate( )` — register an action to take when an Observable completes, either successfully or with an error
- `doOnSubscribe( )` — register an action to take when an observer subscribes to an Observable
- `doOnUnsubscribe( )` — register an action to take when an observer unsubscribes from an Observable
- `finallyDo( )` — register an action to take when an Observable completes
- `delay( )` — shift the emissions from an Observable forward in time by a specified amount
- `delaySubscription( )` — hold an Subscriber's subscription request for a specified amount of time before passing it on to the source Observable
- `timeInterval( )` — emit the time lapsed between consecutive emissions of a source Observable
- `using( )` — create a disposable resource that has the same lifespan as an Observable
- `single( )` — if the Observable completes after emitting a single item, return that item, otherwise throw an exception
- `singleOrDefault( )` — if the Observable completes after emitting a single item, return that item, otherwise return a default item
- `repeat( )` — create an Observable that emits a particular item or sequence of items repeatedly
- `repeatWhen( )` — create an Observable that emits a particular item or sequence of items repeatedly, depending on the emissions of a second Observable


